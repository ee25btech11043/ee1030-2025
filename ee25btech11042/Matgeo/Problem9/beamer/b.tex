\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usetheme{Madrid}
\usecolortheme{default}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{txfonts}
\usepackage{tkz-euclide}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{tabularx}
\usepackage{gvv}
\usepackage{lmodern}
\usepackage{circuitikz}
\usepackage{tikz}
\usepackage{graphicx}

\setbeamertemplate{page number in head/foot}[totalframenumber]

\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}



\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
	breakable=true,
	listing engine=minted,
	listing only,
	minted language=#2,
	minted style=default,
	minted options={%
		linenos,
		gobble=0,
		breaklines=true,
		breakafter=,,
		fontsize=\small,
		numbersep=8pt,
		#1},
	boxsep=0pt,
	left skip=0pt,
	right skip=0pt,
	left=25pt,
	right=0pt,
	top=3pt,
	bottom=3pt,
	arc=5pt,
	leftrule=0pt,
	rightrule=0pt,
	bottomrule=2pt,
	toprule=2pt,
	colback=bg,
	colframe=orange!70,
	enhanced,
	overlay={%
		\begin{tcbclipinterior}
			\fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
	\end{tcbclipinterior}},
	#3,
}
\lstset{
	language=C,
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue},
	stringstyle=\color{orange},
	commentstyle=\color{green!60!black},
	numbers=left,
	numberstyle=\tiny\color{gray},
	breaklines=true,
	showstringspaces=false,
}
%------------------------------------------------------------
%This block of code defines the information to appear in the
%Title page
\title %optional
{5.4.36}
\date{January 9, 2025}
%\subtitle{A short story}

\author % (optional)
{Nipun Dasari - EE25BTECH11042}



\begin{document}
	
	\frame{\titlepage}
	\begin{frame}{Question}
			Using elementary transformations, find the inverse of the following matrix. 
		\begin{align*}
			\myvec{2&-1&-2\\0&2&-1\\3&-5&0}
		\end{align*}
		
	\end{frame}
	
	
	\begin{frame}{Theoretical Solution}
			Let us solve the given question theoretically and then verify the solution computationally.\\
		\\
		To solve for the inverse of a matrix, we can employ the Gauss-Jordan approach.
		\begin{align}
			\augvec{3}{3}{2&-1&-2& 1& 0&0\\ 0&2&-1& 0& 1&0\\3&-5&0& 0& 0&1}
			&\xleftrightarrow{\,R_1 \gets \frac{1}{2}R_1}
			\augvec{3}{3}{1 & -1/2 & -1 & 1/2 & 0 & 0 \\ 0 & 2 & -1 & 0 & 1 & 0 \\ 3 & -5 & 0 & 0 & 0 & 1} \\[1.5em]
			&\xleftrightarrow{\,R_3 \gets R_3 - 3R_1}
			\augvec{3}{3}{1 & -1/2 & -1 & 1/2 & 0 & 0 \\ 0 & 2 & -1 & 0 & 1 & 0 \\ 0 & -7/2 & 3 & -3/2 & 0 & 1} \\[1.5em]
			&\xleftrightarrow{\,R_2 \gets \frac{1}{2}R_2}
			\augvec{3}{3}{1 & -1/2 & -1 & 1/2 & 0 & 0 \\ 0 & 1 & -1/2 & 0 & 1/2 & 0 \\ 0 & -7/2 & 3 & -3/2 & 0 & 1} \\[1.5em]
			&\xleftrightarrow[\,R_3 \gets R_3 + \frac{7}{2}R_2]{\,R_1 \gets R_1 + \frac{1}{2}R_2}
			\augvec{3}{3}{1 & 0 & -5/4 & 1/2 & 1/4 & 0 \\ 0 & 1 & -1/2 & 0 & 1/2 & 0 \\ 0 & 0 & 5/4 & -3/2 & 7/4 & 1} \\[1.5em]
			&\xleftrightarrow{\,R_3 \gets \frac{4}{5}R_3}
			\augvec{3}{3}{1 & 0 & -5/4 & 1/2 & 1/4 & 0 \\ 0 & 1 & -1/2 & 0 & 1/2 & 0 \\ 0 & 0 & 1 & -6/5 & 7/5 & 4/5} \\[1.5em]
			&\xleftrightarrow[\,R_2 \gets R_2 + \frac{1}{2}R_3]{\,R_1 \gets R_1 + \frac{5}{4}R_3}
			\augvec{3}{3}{1 & 0 & 0 & -1 & 2 & 1 \\ 0 & 1 & 0 & -3/5 & 6/5 & 2/5 \\ 0 & 0 & 1 & -6/5 & 7/5 & 4/5}
		\end{align}
	
	\end{frame}
	\begin{frame}{Theoretical Solution}
		
	\begin{align}
		\therefore \text{Inverse of the given Matrix:}\myvec{-1 & 2 & 1 \\-3/5 & 6/5 & 2/5\\-6/5 & 7/5 & 4/5}
	\end{align}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{C Code }
		
		\begin{lstlisting}
			#include <stdio.h>
			#define N 3   // matrix size (you can generalize)
			void inverse(double A[N][N], double inv[N][N]) {
				// Step 1: Create augmented matrix [A|I]
				double aug[N][2*N];
				for (int i = 0; i < N; i++) {
					for (int j = 0; j < N; j++) {
						aug[i][j] = A[i][j];          // copy A
						aug[i][j+N] = (i == j) ? 1 : 0; // identity
					}
				}
			\end{lstlisting}
		\end{frame}
		\begin{frame}[fragile]
			\frametitle{C Code}
			
			\begin{lstlisting}
				// Step 2: Gaussâ€“Jordan elimination
				for (int i = 0; i < N; i++) {
					// Make pivot = 1
					double pivot = aug[i][i];
					for (int j = 0; j < 2*N; j++) {
						aug[i][j] /= pivot;
					}
					// Eliminate other rows
					for (int k = 0; k < N; k++) {
						if (k != i) {
							double factor = aug[k][i];
							for (int j = 0; j < 2*N; j++) {
								aug[k][j] -= factor * aug[i][j];
							}
						}
					}
				}
				
			\end{lstlisting}
		\end{frame}
		\begin{frame}[fragile]
			\frametitle{C Code}
			
			\begin{lstlisting}
				// Step 3: Extract inverse from augmented matrix
				for (int i = 0; i < N; i++) {
					for (int j = 0; j < N; j++) {
						inv[i][j] = aug[i][j+N];
					}
				}
				
				
			\end{lstlisting}
		\end{frame}
		
		
		\begin{frame}[fragile]
			\frametitle{Python Code using shared output}
			\begin{lstlisting}
			import ctypes
			import numpy as np
			import sympy as sp
			# Load C library
			lib = ctypes.CDLL("./5.4.36.so")
			# Define function signature
			lib.inverse.argtypes = [ctypes.POINTER((ctypes.c_double * 3) * 3),
			ctypes.POINTER((ctypes.c_double * 3) * 3)]
			\end{lstlisting}
		\end{frame}
		\begin{frame}[fragile]
			\frametitle{Python Code using shared output}
			\begin{lstlisting}		
				# Input matrix
				A = np.array([[2, -1, -2],
				[0, 2, -1],
				[3, -5, 0]], dtype=np.double)
				
				inv = np.zeros((3,3), dtype=np.double)
				# Call C function
				lib.inverse(A.ctypes.data_as(ctypes.POINTER((ctypes.c_double * 3) * 3)),
				inv.ctypes.data_as(ctypes.POINTER((ctypes.c_double * 3) * 3)))
				inverse=sp.Matrix(inv)
				sp.pprint(inverse)
			\end{lstlisting}
		\end{frame}
		
		\begin{frame}[fragile]
			\frametitle{Python Code}
			\begin{lstlisting}
				import sympy as sp
				A = sp.Matrix([[2, -1, -2], [0, 2, -1],[3, -5, 0]])
				A_inv = A.inv()
				sp.pprint(A_inv) 
			\end{lstlisting}
			
		\end{frame}
		
		
		
	\end{document}