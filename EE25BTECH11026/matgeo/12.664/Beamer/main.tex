\documentclass{beamer}
\usepackage[utf8]{inputenc}

\usetheme{Madrid}
\usecolortheme{default}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{mathtools}
\usepackage{txfonts}
\usepackage{tkz-euclide}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{gensymb}
\usepackage{tabularx}
\usepackage{gvv}
\usepackage{lmodern}
\usepackage{circuitikz}
\usepackage{tikz}
\usepackage{multicol}
\lstset{literate={·}{{$\cdot$}}1 {λ}{{$\lambda$}}1 {→}{{$\to$}}1}
\usepackage{graphicx}

\setbeamertemplate{page number in head/foot}[totalframenumber]

\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}



\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
  breakable=true,
  listing engine=minted,
  listing only,
  minted language=#2,
  minted style=default,
  minted options={%
    linenos,
    gobble=0,
    breaklines=true,
    breakafter=,,
    fontsize=\small,
    numbersep=8pt,
    #1},
  boxsep=0pt,
  left skip=0pt,
  right skip=0pt,
  left=25pt,
  right=0pt,
  top=3pt,
  bottom=3pt,
  arc=5pt,
  leftrule=0pt,
  rightrule=0pt,
  bottomrule=2pt,
  toprule=2pt,
  colback=bg,
  colframe=orange!70,
  enhanced,
  overlay={%
    \begin{tcbclipinterior}
    \fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
    \end{tcbclipinterior}},
  #3,
}
\lstset{
    language=C,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{orange},
    commentstyle=\color{green!60!black},
    numbers=left,
    numberstyle=\tiny\color{gray},
    breaklines=true,
    showstringspaces=false,
}
%------------------------------------------------------------
%This block of code defines the information to appear in the
%Title page
\title %optional
{12.664}
\date{September 20,2025}
%\subtitle{A short story}

\author % (optional)
{Harsha-EE25BTECH11026}



\begin{document}


\frame{\titlepage}


\begin{frame}{Question}
A real, invertible $3 \times 3$ matrix $\vec{M}$ has eigenvalues $\lambda_i$, $\brak{i=1,2,3}$ and the corresponding eigenvectors are $\vec{e_i}$, $\brak{i=1,2,3}$ respectively. Which one of the following is correct?
\begin{enumerate}
    \item $\vec{M}\vec{e_i}=\frac{1}{\lambda_i}\vec{e_i}$, for i=1,2,3
    \item $\vec{M}^{-1}\vec{e_i}=\frac{1}{\lambda_i}\vec{e_i}$, for i=1,2,3
    \item $\vec{M}^{-1}\vec{e_i}=\lambda_i\vec{e_i}$, for i=1,2,3
    \item The eigenvalues of $\vec{M}$ and $\vec{M}^{-1}$ are not related.
\end{enumerate}
\end{frame}

\begin{frame}{Theoretical Solution}
According to the definition of eigen-vector,
\begin{align}
    \vec{M}\vec{e_i}=\lambda_i\vec{e_i}
\end{align}
Pre-multiplying $\vec{M}^{-1}$ on both sides,
\begin{align}
    \therefore \brak{\vec{M}^{-1}\vec{M}}\vec{e_i}=\vec{M}^{-1}\lambda_i\vec{e_i}
\end{align}
\begin{align}
    \implies \vec{e_i}=\lambda_i\vec{M}^{-1}\vec{e_i}
\end{align}
\begin{align}
    \therefore \vec{M}^{-1}\vec{e_i}=\frac{1}{\lambda_i}\vec{e_i}
\end{align}
\end{frame}

\begin{frame}[fragile]
    \frametitle{C Code -Verifying the relation between the eigenvalues of a matrix and its inverse}

    \begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h>

#define N 10  

int inverse(int n, double A[N][N], double Inv[N][N]) {
    double aug[N][2*N];

    // Form augmented matrix [A|I]
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            aug[i][j] = A[i][j];
        }
        for (int j = 0; j < n; j++) {
            aug[i][j+n] = (i==j) ? 1.0 : 0.0;
        }
    }
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{C Code -Verifying the relation between the eigenvalues of a matrix and its inverse}

    \begin{lstlisting}[language=C]
    for (int i = 0; i < n; i++) {
        double pivot = aug[i][i];
        if (fabs(pivot) < 1e-12) {
            return 0; // singular
        }
        // Normalize row
        for (int j = 0; j < 2*n; j++) {
            aug[i][j] /= pivot;
        }
        // Eliminate other rows
        for (int k = 0; k < n; k++) {
            if (k != i) {
                double factor = aug[k][i];
                for (int j = 0; j < 2*n; j++) {
                    aug[k][j] -= factor * aug[i][j];
                }
            }}}
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{C Code -Verifying the relation between the eigenvalues of a matrix and its inverse}

    \begin{lstlisting}[language=C]
   for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            Inv[i][j] = aug[i][j+n];
        }
    }

    return 1; 
}

void qr_iteration(int n, double A[N][N], double eigvals[N], int max_iter, double tol) {
    double Q[N][N], R[N][N], Ak[N][N];
    for (int i = 0; i < n; i++)
        for (int j = 0; j < n; j++)
            Ak[i][j] = A[i][j];

    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{C Code -Verifying the relation between the eigenvalues of a matrix and its inverse}

    \begin{lstlisting}[language=C]
 for (int iter = 0; iter < max_iter; iter++) {
        // Gram-Schmidt to compute QR
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < n; i++) Q[i][j] = Ak[i][j];
            for (int k = 0; k < j; k++) {
                double dot = 0;
                for (int i = 0; i < n; i++) dot += Q[i][k] * Ak[i][j];
                for (int i = 0; i < n; i++) Q[i][j] -= dot * Q[i][k];
            }
            double norm = 0;
            for (int i = 0; i < n; i++) norm += Q[i][j]*Q[i][j];
            norm = sqrt(norm);
            for (int i = 0; i < n; i++) Q[i][j] /= norm;
        }
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{C Code -Verifying the relation between the eigenvalues of a matrix and its inverse}

    \begin{lstlisting}[language=C]
  // R = Q^T * A
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                R[i][j] = 0;
                for (int k = 0; k < n; k++) R[i][j] += Q[k][i] * Ak[k][j];
            }
        // Ak = R * Q
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++) {
                Ak[i][j] = 0;
                for (int k = 0; k < n; k++) Ak[i][j] += R[i][k] * Q[k][j];
            }
    }
    for (int i = 0; i < n; i++) eigvals[i] = Ak[i][i];
}
    \end{lstlisting}
\end{frame}



\begin{frame}[fragile]
    \frametitle{Python+C code}

    \begin{lstlisting}[language=Python]
import ctypes
import numpy as np

lib = ctypes.CDLL("./libmatrix_ops.so")

N = 10
MAX_ITER = 1000
TOL = 1e-9
# Define argument types
lib.inverse.argtypes = [ctypes.c_int,
                        (ctypes.c_double * N * N),
                        (ctypes.c_double * N * N)]
lib.inverse.restype = ctypes.c_int
lib.qr_iteration.argtypes = [ctypes.c_int,(ctypes.c_double * N * N),
                (ctypes.c_double * N),ctypes.c_int,ctypes.c_double]
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Python+C code}

    \begin{lstlisting}[language=Python]
def matrix_inverse(A: np.ndarray):
    n = A.shape[0]
    A_c = (ctypes.c_double * N * N)()
    Inv_c = (ctypes.c_double * N * N)()

    for i in range(n):
        for j in range(n):
            A_c[i][j] = A[i, j]

    success = lib.inverse(n, A_c, Inv_c)
    if not success:
        raise ValueError("Matrix is singular")
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Python+C code}

    \begin{lstlisting}[language=Python]
Inv = np.zeros((n, n))
    for i in range(n):
        for j in range(n):
            Inv[i, j] = Inv_c[i][j]

    return Inv

# Wrapper: Eigenvalues
def eigenvalues(A: np.ndarray):
    n = A.shape[0]
    A_c = (ctypes.c_double * N * N)()
    eig_c = (ctypes.c_double * N)()

    for i in range(n):
        for j in range(n):
            A_c[i][j] = A[i, j]
    lib.qr_iteration(n, A_c, eig_c, MAX_ITER, TOL)
    return np.round(np.array([eig_c[i] for i in range(n)]), 3)
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Python+C code}

    \begin{lstlisting}[language=Python]
# Example 
if __name__ == "__main__":
    A = np.array([[4.0, 2.0, 1.0],
                  [1.0, 3.0, 2.0],
                  [0.0, 5.0, 6.0]])
    B=matrix_inverse(A)
    print("Eigenvalues of A:",eigenvalues(A))
    print("Eigenvalues of B:",eigenvalues(B))
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Python code}
    \begin{lstlisting}[language=Python]
import numpy as np

#Example matrix
A=np.matrix([[1,3,4],[5,4,9],[2,7,6]])

B=np.linalg.inv(A)

eigvals=np.linalg.eigvals(A)
print("The eigen values of matrix A:",np.round(eigvals,3))
eigvals_inv=np.linalg.eigvals(B)
print(r"The eigen values of matrix B:",np.round(eigvals_inv,3))
    \end{lstlisting}   
\end{frame}

\end{document}