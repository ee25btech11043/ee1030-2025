\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usetheme{Madrid}
\usecolortheme{default}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{txfonts}
\usepackage{tkz-euclide}
\usepackage{listings}
\usepackage{adjustbox}
\usepackage{array}
\usepackage{tabularx}
\usepackage{gvv}
\usepackage{lmodern}
\usepackage{circuitikz}
\usepackage{tikz}
\usepackage{graphicx}
\setbeamertemplate{page number in head/foot}[totalframenumber]
\usepackage{tcolorbox}
\tcbuselibrary{minted,breakable,xparse,skins}
\definecolor{bg}{gray}{0.95}
\DeclareTCBListing{mintedbox}{O{}m!O{}}{%
breakable=true,
listing engine=minted,
listing only,
minted language=#2,
minted style=default,
minted options={%
linenos,
gobble=0,
breaklines=true,
breakafter=,,
fontsize=\small,
numbersep=8pt,
#1},
boxsep=0pt,
left skip=0pt,
right skip=0pt,
left=25pt,
right=0pt,
top=3pt,
bottom=3pt,
arc=5pt,
leftrule=0pt,
rightrule=0pt,
bottomrule=2pt,
toprule=2pt,
colback=bg,
colframe=orange!70,
enhanced,
overlay={%
\begin{tcbclipinterior}
\fill[orange!20!white] (frame.south west) rectangle ([xshift=20pt]frame.north west);
\end{tcbclipinterior}},
#3,
}
\lstset{
language=C,
basicstyle=\ttfamily\small,
keywordstyle=\color{blue},
stringstyle=\color{orange},
commentstyle=\color{green!60!black},
numbers=left,
numberstyle=\tiny\color{gray},
breaklines=true,
showstringspaces=false,
}

\title{12.784}
\date{October 11, 2025}
\author{EE25BTECH11043 - Nishid Khandagre}

\begin{document}

\frame{\titlepage}

\begin{frame}{Question}
Let A = $(a_{ij})$ be a 3 $\times$ 3 real matrix such that
A $\myvec{1\\2\\1}$ = 2$\myvec{1\\2\\1}$, A $\myvec{0\\1\\1}$ = 2$\myvec{0\\1\\1}$ and A$\myvec{-1\\1\\0}$ = 4$\myvec{-1\\1\\0}$.
If $m$ is the degree of the minimal polynomial of A, then $a_{11} + a_{21} + a_{31} + m$ equals
\end{frame}

\begin{frame}{Theoretical Solution}
\textbf{Solution: }
Given eigen relations:
\begin{align}
\vec{A} \myvec{1\\2\\1} = 2\myvec{1\\2\\1} \\
\vec{A} \myvec{0\\1\\1} = 2\myvec{0\\1\\1} \\
\vec{A} \myvec{-1\\1\\0} = 4\myvec{-1\\1\\0}
\end{align}
\end{frame}

\begin{frame}{Theoretical Solution}
The eigenvectors are :
\begin{align}
\vec{v_1} = \myvec{1\\2\\1}, \quad
\vec{v_2} = \myvec{0\\1\\1}, \quad
\vec{v_3} = \myvec{-1\\1\\0}
\end{align}
as $\vec{v_1},\vec{v_2},\vec{v_3}$ are linearly independent.\\

Form the matrix $\vec{P}$ with these eigenvectors as columns:
\begin{align}
\vec{P} = \myvec{
1 & 0 & -1 \\
2 & 1 & 1 \\
1 & 1 & 0
}
\end{align}
\end{frame}

\begin{frame}{Theoretical Solution}
The inverse of $\vec{P}$ is:
\begin{align}
\vec{P}^{-1} =
\myvec{
\frac{1}{2} & \frac{1}{2} & -\frac{1}{2} \\
-\frac{1}{2} & -\frac{1}{2} & \frac{3}{2} \\
-\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}
}
\end{align}

\begin{align}
\vec{P}=\myvec{\vec{v_1}&\vec{v_2}&\vec{v_3}}\\
\vec{A}\vec{P}=\myvec{\vec{A}\vec{v_1}&\vec{A}\vec{v_2}&\vec{A}\vec{v_3}}\\
\vec{A}\vec{P}=\myvec{2\vec{v_1}&2\vec{v_2}&4\vec{v_3}}
\end{align}
\begin{align}
\vec{A}\vec{P}=\vec{P}\vec{D}
\end{align}
\begin{align}
\vec{D}=
\myvec{
2 & 0 & 0 \\
0 & 2 & 0 \\
0 & 0 & 4
}
\end{align}
\end{frame}

\begin{frame}{Theoretical Solution}
\begin{align}
\vec{PD} &= \myvec{
1 & 0 & -1 \\
2 & 1 & 1 \\
1 & 1 & 0
}
\begin{pmatrix}
2 & 0 & 0 \\
0 & 2 & 0 \\
0 & 0 & 4
\end{pmatrix} \\
&= \begin{pmatrix}
2 & 0 & -4 \\
4 & 2 & 4 \\
2 & 2 & 0
\end{pmatrix}
\end{align}
Now, compute $\vec{A} = \vec{PD}\vec{P}^{-1}$:
\begin{align}
\vec{A} &= \myvec{
2 & 0 & -4 \\
4 & 2 & 4 \\
2 & 2 & 0
}
\myvec{
\frac{1}{2} & \frac{1}{2} & -\frac{1}{2} \\
-\frac{1}{2} & -\frac{1}{2} & \frac{3}{2} \\
-\frac{1}{2} & \frac{1}{2} & -\frac{1}{2}
}
\end{align}
\end{frame}

\begin{frame}{Theoretical Solution}
\begin{align}
\vec{A} = \myvec{
3 & -1 & 1 \\
-1 & 3 & -1 \\
0 & 0 & 2
}
\end{align}
The sum of the first column elements is:
\begin{align}
a_{11} + a_{21} + a_{31} = 3 + (-1) + 0 = 2
\end{align}
The eigenvalues of $\vec{A}$ are 2 (with algebraic multiplicity 2) and 4 (with algebraic multiplicity 1).\\
\end{frame}

\begin{frame}{Theoretical Solution}
Since there are three linearly independent eigenvectors, the matrix $\vec{A}$ is diagonalizable. The minimal polynomial is the product of distinct linear factors corresponding to the eigenvalues.
\begin{align}
m_A(x) = (x-2)(x-4)
\end{align}
The degree of the minimal polynomial, $m$ is 2.

\begin{align}
a_{11} + a_{21} + a_{31} + m = 2 + 2 = 4
\end{align}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}[language=C]
#include <stdio.h>
#include <math.h> // For fabs() for determinant calculation tolerance

// Function to calculate the determinant of a 3x3 matrix
double determinant_3x3(double m[3][3]) {
    return m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1]) -
           m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0]) +
           m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);
}
// Function to calculate the inverse of a 3x3 matrix
// Returns 1 on success, 0 on failure (singular matrix)
int inverse_3x3(double m[3][3], double inv[3][3]) {
    double det = determinant_3x3(m);
    if (fabs(det) < 1e-9) { // Check for singularity (determinant close to zero)
        return 0; // Singular matrix, inverse does not exist
    }
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}[language=C]
    double invDet = 1.0 / det;

    inv[0][0] = (m[1][1] * m[2][2] - m[1][2] * m[2][1]) * invDet;
    inv[0][1] = (m[0][2] * m[2][1] - m[0][1] * m[2][2]) * invDet;
    inv[0][2] = (m[0][1] * m[1][2] - m[0][2] * m[1][1]) * invDet;

    inv[1][0] = (m[1][2] * m[2][0] - m[1][0] * m[2][2]) * invDet;
    inv[1][1] = (m[0][0] * m[2][2] - m[0][2] * m[2][0]) * invDet;
    inv[1][2] = (m[0][2] * m[1][0] - m[0][0] * m[1][2]) * invDet;

    inv[2][0] = (m[1][0] * m[2][1] - m[1][1] * m[2][0]) * invDet;
    inv[2][1] = (m[0][1] * m[2][0] - m[0][0] * m[2][1]) * invDet;
    inv[2][2] = (m[0][0] * m[1][1] - m[0][1] * m[1][0]) * invDet;

    return 1; // Success
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}[language=C]
// Function to multiply a 3x3 matrix by a 3x1 vector
void multiply_mat_vec_3x3(double mat[3][3], double vec[3], double result[3]) {
    result[0] = mat[0][0] * vec[0] + mat[0][1] * vec[1] + mat[0][2] * vec[2];
    result[1] = mat[1][0] * vec[0] + mat[1][1] * vec[1] + mat[1][2] * vec[2];
    result[2] = mat[2][0] * vec[0] + mat[2][1] * vec[1] + mat[2][2] * vec[2];
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}[language=C]
// Main function to solve the problem
// It takes pointers to return the calculated sum and minimal polynomial degree
void solve_matrix_problem_simplified(double *result_sum, int *minimal_poly_degree) {
    // 1. Determine minimal polynomial degree (m)
    // Distinct eigenvalues are 2 and 4.
    // Minimal polynomial m(x) = (x - 2)(x - 4), degree = 2.
    *minimal_poly_degree = 2;
    //2.Find coefficients c1, c2, c3 for e1 = c1*v1+c2*v2+c3*v3
    // v1 = [1, 2, 1]^T, v2 = [0, 1, 1]^T, v3 = [-1, 1, 0]^T
    // Equation: P * [c1, c2, c3]^T = [1, 0, 0]^T, where P = [v1 | v2 | v3]
    double P_matrix[3][3] = {
        {1.0, 0.0, -1.0},
        {2.0, 1.0, 1.0},
        {1.0, 1.0, 0.0}
    };
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}[language=C]
    double e1_vec[3] = {1.0, 0.0, 0.0};
    double P_inverse[3][3];
    int success = inverse_3x3(P_matrix, P_inverse); // Calculate inverse
    if (!success) { /* Handle error for singular P_matrix */ return; }
    double c_vec[3]; // To store [c1, c2, c3]^T

    // [c1, c2, c3]^T = P_inverse * e1_vec
    multiply_mat_vec_3x3(P_inverse, e1_vec, c_vec);

    double c1 = c_vec[0];
    double c2 = c_vec[1];
    double c3 = c_vec[2];
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code: Solution Logic}
\begin{lstlisting}[language=C]
    // 3. Calculate A*e1 = a11, a21, a31
    // A*e1 = c1*(A*v1) + c2*(A*v2) + c3*(A*v3)
    // A*e1 = c1*(lambda1*v1) + c2*(lambda2*v2) + c3*(lambda3*v3)
    // A*e1 = c1*(2*v1) + c2*(2*v2) + c3*(4*v3)

    double v1_arr[3] = {1.0, 2.0, 1.0};
    double v2_arr[3] = {0.0, 1.0, 1.0};
    double v3_arr[3] = {-1.0, 1.0, 0.0};

    double a11_a21_a31_vec[3] = {0.0, 0.0, 0.0};

    // Add c1 * 2 * v1
    a11_a21_a31_vec[0] += c1 * 2.0 * v1_arr[0];
    a11_a21_a31_vec[1] += c1 * 2.0 * v1_arr[1];
    a11_a21_a31_vec[2] += c1 * 2.0 * v1_arr[2];
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{C Code}
\begin{lstlisting}[language=C]
    // Add c2 * 2 * v2
    a11_a21_a31_vec[0] += c2 * 2.0 * v2_arr[0];
    a11_a21_a31_vec[1] += c2 * 2.0 * v2_arr[1];
    a11_a21_a31_vec[2] += c2 * 2.0 * v2_arr[2];

    // Add c3 * 4 * v3
    a11_a21_a31_vec[0] += c3 * 4.0 * v3_arr[0];
    a11_a21_a31_vec[1] += c3 * 4.0 * v3_arr[1];
    a11_a21_a31_vec[2] += c3 * 4.0 * v3_arr[2];

    double a11 = a11_a21_a31_vec[0];
    double a21 = a11_a21_a31_vec[1];
    double a31 = a11_a21_a31_vec[2];

    // 4. Calculate the final sum
    *result_sum = a11 + a21 + a31 + (*minimal_poly_degree);
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (using C shared library)}
\begin{lstlisting}[language=Python]
import ctypes
import numpy as np

# Load the shared library
lib_matrix = ctypes.CDLL("./code26.so")

# Define argument types and return type for the C function
lib_matrix.solve_matrix_problem_simplified.argtypes = [
    ctypes.POINTER(ctypes.c_double),  # result_sum
    ctypes.POINTER(ctypes.c_int)       # minimal_poly_degree
]
lib_matrix.solve_matrix_problem_simplified.restype = None

# Create ctypes variables to hold the results
result_sum = ctypes.c_double()
minimal_poly_degree = ctypes.c_int()
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (using C shared library)}
\begin{lstlisting}[language=Python]
# Call the C function to solve the problem
lib_matrix.solve_matrix_problem_simplified(
    ctypes.byref(result_sum),
    ctypes.byref(minimal_poly_degree)
)

# Extract the values from the ctypes variables
final_sum = result_sum.value
degree_m = minimal_poly_degree.value

print(f"The degree of the minimal polynomial (m) is: {degree_m}")
print(f"The value of a11 + a21 + a31 + m is: {final_sum:.2f}")
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (Pure Python Solution)}
\begin{lstlisting}[language=Python]
import numpy as np

def solve_matrix_problem_pure_python():
    """
    Solves the given matrix problem using pure Python and NumPy.
    Calculates a11 + a21 + a31 + m.
    """
    # 1. Analyze the given information to find eigenvalues and eigenvectors
    v1 = np.array([1, 2, 1]); lambda1 = 2
    v2 = np.array([0, 1, 1]); lambda2 = 2
    v3 = np.array([-1, 1, 0]); lambda3 = 4

    print("--- Problem Analysis ---")
    print(f"Eigenvector v1: {v1}, Eigenvalue: {lambda1}")
    print(f"Eigenvector v2: {v2}, Eigenvalue: {lambda2}")
    print(f"Eigenvector v3: {v3}, Eigenvalue: {lambda3}")
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (Pure Python Solution)}
\begin{lstlisting}[language=Python]
    # Check for linear independence of eigenvectors
    P_check = np.array([v1, v2, v3]).T
    det_P = np.linalg.det(P_check)
    print(f"Determinant of eigenvector matrix P: {det_P:.2f}")
    if np.isclose(det_P, 0):
        print("Warning: Eigenvectors are linearly dependent.")
    else:
        print("Eigenvectors are linearly independent, so A is diagonalizable.")

    # 2. Determine the degree of the minimal polynomial (m)
    distinct_eigenvalues = {lambda1, lambda2, lambda3}
    m = len(distinct_eigenvalues)
    print(f"\nDistinct Eigenvalues: {distinct_eigenvalues}")
    print(f"Degree of the minimal polynomial (m): {m}")
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (Pure Python Solution)}
\begin{lstlisting}[language=Python]
    # 3. Find the first column of matrix A (a11, a21, a31)
    # This is A * e1, where e1 = [1, 0, 0]^T.
    # e1 = c1 * v1 + c2 * v2 + c3 * v3  => P * [c1, c2, c3]^T = e1
    P_matrix = np.array([v1, v2, v3]).T
    e1_vector = np.array([1, 0, 0])

    P_inverse = np.linalg.inv(P_matrix)
    print(f"\nMatrix P:\n{P_matrix}")
    print(f"Inverse of P:\n{P_inverse}")

    c_coefficients = np.dot(P_inverse, e1_vector)
    c1, c2, c3 = c_coefficients
    print(f"Coefficients (c1, c2, c3): c1={c1:.4f}, c2={c2:.4f}, c3={c3:.4f}")
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (Pure Python Solution)}
\begin{lstlisting}[language=Python]
    # Calculate A * e1 = c1*(lambda1*v1) + c2*(lambda2*v2) + c3*(lambda3*v3)
    first_column_of_A = (c1 * lambda1 * v1) + \
                        (c2 * lambda2 * v2) + \
                        (c3 * lambda3 * v3)

    a11 = first_column_of_A[0]
    a21 = first_column_of_A[1]
    a31 = first_column_of_A[2]

    print(f"\nCalculated first column of A: {first_column_of_A}")
    print(f"a11: {a11:.4f}, a21: {a21:.4f}, a31: {a31:.4f}")
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Python Code (Pure Python Solution)}
\begin{lstlisting}[language=Python]
    # 4. Calculate the final sum: a11 + a21 + a31 + m
    final_sum = a11 + a21 + a31 + m

    print(f"\n--- Final Result ---")
    print(f"a11 + a21 + a31 + m = {final_sum:.2f}")
    return final_sum

if __name__ == "__main__":
    solve_matrix_problem_pure_python()
\end{lstlisting}
\end{frame}


\end{document}